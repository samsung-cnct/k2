---
- name: Add bootcmd to install custom docker for {{ node.name }}
  set_fact:
    cloud_config: "{{ cloud_config | default({}) | combine(new_cloud_config, recursive=true) }}"
  vars:
    command:
      - "/bin/bash <(/usr/bin/curl https://s3-us-west-2.amazonaws.com/samsung-cnct/artifacts/install-artifact.sh) -u {{ node.containerConfig.url }} -l /var/run/cnct-docker-installed.lock"
    bootcmds: "{{ cloud_config[cluster.name][node.name].bootcmd | default([]) }}"
    new_cloud_config: '{{ { cluster.name: { node.name: { "bootcmd": bootcmds + command }}} }}'
  when: (node.containerConfig.url is defined) and node.containerConfig.runtime == "docker" and node.containerConfig.type == "tgz"

- name: Add drop-in for docker and containerd services for {{ node.name }}
  set_fact:
    cloud_config: "{{ cloud_config | default({}) | combine(new_cloud_config, recursive=true) }}"
  vars:
    new_files:
      - path: /etc/systemd/system/docker.service.d/exec-docker.conf
        content: |
          [Service]
          ExecStart=
          ExecStart=/opt/cnct/bin/dockerd \
            --add-runtime docker-runc=/opt/cnct/bin/docker-runc \
            --default-runtime=docker-runc \
            --exec-opt native.cgroupdriver=systemd \
            $OPTIONS \
            $DOCKER_STORAGE_OPTIONS \
            $DOCKER_NETWORK_OPTIONS \
            $ADD_REGISTRY \
            $BLOCK_REGISTRY \
            $INSECURE_REGISTRY
      - path: /etc/systemd/system/containerd.service.d/exec-containerd.conf
        content: |
          [Service]
          ExecStart=
          ExecStart=/opt/cnct/bin/docker-containerd \
            --listen unix:///var/run/docker/libcontainerd/docker-containerd.sock \
            --shim /opt/cnct/bin/docker-containerd-shim \
            --state-dir /var/run/docker/libcontainerd/containerd \
            --runtime /opt/cnct/bin/docker-runc
    write_files: "{{ cloud_config[cluster.name][node.name].write_files | default([]) }}"
    new_cloud_config: '{{ { cluster.name: { node.name: { "write_files": write_files + new_files }}} }}'
  when: (node.containerConfig.url is defined) and node.containerConfig.runtime == "docker" and node.containerConfig.type == "tgz"

- name: Add package install to cloud_init
  set_fact:
    cloud_config: "{{ cloud_config | default({}) | combine(new_cloud_config, recursive=true) }}"
  vars:
    package_name:
      ubuntu: docker.io
    new_packages: [ "{{ package_name[ node.osConfig.type | lower ] | default(none) }}" ]
    old_packages: "{{ cloud_config[cluster.name][node.name].packages | default([]) }}"
    new_cloud_config: '{{ { cluster.name: { node.name: { "packages": old_packages + new_packages }}} }}'
  when: node.containerConfig.runtime == "docker" and node.containerConfig.type == "distro"

- name: Add runcmd to restart docker and containerd for {{ node.name }}
  set_fact:
    cloud_config: "{{ cloud_config | default({}) | combine(new_cloud_config, recursive=true) }}"
  vars:
    new_runcmd:
      - [ systemctl, daemon-reload ]
      - [ systemctl, restart, --no-block, docker ]
    runcmd: "{{ cloud_config[cluster.name][node.name].runcmd | default([]) }}"
    new_cloud_config: '{{ { cluster.name: { node.name: { "runcmd": runcmd + new_runcmd }}} }}'

- name: Add runcmd to restart containerd service if distro supports it for {{ node.name }}
  set_fact:
    cloud_config: "{{ cloud_config | default({}) | combine(new_cloud_config, recursive=true) }}"
  vars:
    new_runcmd:
      - [ systemctl, restart, --no-block, containerd ]
    runcmd: "{{ cloud_config[cluster.name][node.name].runcmd | default([]) }}"
    new_cloud_config: '{{ { cluster.name: { node.name: { "runcmd": runcmd + new_runcmd }}} }}'
  when: (node.osConfig.type | lower) == "coreos"
